<?xml version="1.0"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>http://example.com</id>
    <title>DzcGood • Posts by &#34;锁&#34; tag</title>
    <link href="http://example.com" />
    <updated>2021-12-11T15:45:14.000Z</updated>
    <category term="leetcode" />
    <category term="数组" />
    <category term="二分查找" />
    <category term="编译原理" />
    <category term="SCNU-CS" />
    <category term="Linux" />
    <category term="锁" />
    <category term="MySQL" />
    <category term="学习笔记" />
    <category term="Redis" />
    <category term="Jedis" />
    <category term="JavaSE" />
    <category term="XLEX" />
    <category term="MySql" />
    <category term="JDBC" />
    <entry>
        <id>http://example.com/2021/12/11/Lock/</id>
        <title>锁</title>
        <link rel="alternate" href="http://example.com/2021/12/11/Lock/"/>
        <content type="html">&lt;h1 id=&#34;锁&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#锁&#34;&gt;#&lt;/a&gt; 锁&lt;/h1&gt;
&lt;h2 id=&#34;基于标志的锁&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#基于标志的锁&#34;&gt;#&lt;/a&gt; 基于标志的锁&lt;/h2&gt;
&lt;p&gt;以下是基于标志（flag）的锁的实现方式：&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter hljs&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs c++&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; __&lt;span class=&#34;hljs-title&#34;&gt;lock_t&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; flag;&amp;#125; &lt;span class=&#34;hljs-keyword&#34;&gt;lock_t&lt;/span&gt;;&lt;br&gt;&lt;br&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;init&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;lock_t&lt;/span&gt; *mutex)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;br&gt;    &lt;span class=&#34;hljs-comment&#34;&gt;// 0 -&amp;gt; lock is available, 1 -&amp;gt; held&lt;/span&gt;&lt;br&gt;    mutex -&amp;gt; flag = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;br&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;lock_t&lt;/span&gt; *mutex)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;br&gt;    &lt;span class=&#34;hljs-keyword&#34;&gt;while&lt;/span&gt;(mutex -&amp;gt; flag == &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;) &lt;span class=&#34;hljs-comment&#34;&gt;// TEST the flag&lt;/span&gt;&lt;br&gt;        ;&lt;span class=&#34;hljs-comment&#34;&gt;// spin-wait(do nothing)&lt;/span&gt;&lt;br&gt;    mutex -&amp;gt; flag = &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;br&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;lock_t&lt;/span&gt; *mutex)&lt;/span&gt;&lt;/span&gt;&amp;#123;&lt;br&gt;    mutex -&amp;gt; flag = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;11&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#11&#34;&gt;#&lt;/a&gt; 1.1&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;第 10 行的注释，spin-wait，是什么意思？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答： &lt;code&gt;spin-wait&lt;/code&gt;  是指自旋等待， &lt;code&gt;flag&lt;/code&gt;  为 1 时，线程反复检查锁变量是否可用； &lt;code&gt;flag&lt;/code&gt;  为 0 时，说明锁变量可用，设置 &lt;code&gt;flag&lt;/code&gt;  为 1 表示保持该锁。&lt;/p&gt;
&lt;h3 id=&#34;12&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#12&#34;&gt;#&lt;/a&gt; 1.2&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;假设没有底层硬件或者操作系统的相关支持，该锁用于进程间的互斥，则其实现方式会有什么问题？请详细说明。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答：获取、释放锁，实际上是读写存储内存或寄存器，因此这种读写操作必须是原子的。如果没有底层硬件或者操作系统的支持，那么就无法保证其操作的原子性。对于 &lt;code&gt;lock函数&lt;/code&gt; ， &lt;code&gt;flag&lt;/code&gt;  检测和设置本该是一体的，但由于无法保证原子性，那么 &lt;code&gt;while&lt;/code&gt;  和 &lt;code&gt;mutex -&amp;gt; flag = 1&lt;/code&gt;  之间就可能混入其他线程的操作，例如线程 A 执行到 &lt;code&gt;mutex-&amp;gt;flag = 1&lt;/code&gt;  语句之前，另一个线程 B 运行到 &lt;code&gt;while&lt;/code&gt; ，由于 &lt;code&gt;mutex-&amp;gt;flag&lt;/code&gt;  还未被赋值为 1，线程 B 也可以跳出 &lt;code&gt;while&lt;/code&gt; ，于是线程 A 和 B 都拿到了这把锁。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;基于test-and-set原子指令的锁&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#基于test-and-set原子指令的锁&#34;&gt;#&lt;/a&gt; 基于 Test-and-Set 原子指令的锁&lt;/h2&gt;
&lt;p&gt;以下是 &lt;code&gt;Test-and-Set&lt;/code&gt;  原子指令的实现逻辑：&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter hljs&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs c++&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;TestAndSet&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; *old_ptr, &lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt;)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;br&gt;	&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; old = *old_ptr;	&lt;span class=&#34;hljs-comment&#34;&gt;//fetch old value at old_ptr&lt;/span&gt;&lt;br&gt; 	*old_ptr = &lt;span class=&#34;hljs-keyword&#34;&gt;new&lt;/span&gt;;	&lt;span class=&#34;hljs-comment&#34;&gt;//store ‘new’ into old_ptr&lt;/span&gt;&lt;br&gt; 	&lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt; old;	&lt;span class=&#34;hljs-comment&#34;&gt;//return the old value&lt;/span&gt;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;以下是基于  &lt;code&gt;Test-and-Set&lt;/code&gt;  指令的锁实现方式：&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter hljs&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs c++&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;typedef&lt;/span&gt; &lt;span class=&#34;hljs-class&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;struct&lt;/span&gt; __&lt;span class=&#34;hljs-title&#34;&gt;lock_t&lt;/span&gt; &amp;#123;&lt;/span&gt;&lt;br&gt; 	&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; flag;&lt;br&gt;&amp;#125; &lt;span class=&#34;hljs-keyword&#34;&gt;lock_t&lt;/span&gt;;&lt;br&gt;&lt;br&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;init&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;lock_t&lt;/span&gt; *lock)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;br&gt;	&lt;span class=&#34;hljs-comment&#34;&gt;// 0 indicates that lock is available, 1 that it is held&lt;/span&gt;&lt;br&gt;	lock-&amp;gt;flag = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;br&gt; &lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;lock&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;lock_t&lt;/span&gt; *lock)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;br&gt;	&lt;span class=&#34;hljs-keyword&#34;&gt;while&lt;/span&gt; (&lt;span class=&#34;hljs-built_in&#34;&gt;TestAndSet&lt;/span&gt;(&amp;amp;lock-&amp;gt;flag, &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;) == &lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;)&lt;br&gt;	; &lt;span class=&#34;hljs-comment&#34;&gt;// spin-wait (do nothing)&lt;/span&gt;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;br&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;unlock&lt;/span&gt;&lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;lock_t&lt;/span&gt; *lock)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;br&gt;	lock-&amp;gt;flag = &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;21&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#21&#34;&gt;#&lt;/a&gt; 2.1&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&amp;quot;基于 Test-and-Set&amp;quot; 指令的锁实现方式，是否可以解决 1.2 中，“基于标志 （flag）的锁实现方式” 所存在的问题，为什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答：可以。“返回旧值” 和 “设置新值” 这两个操作共同组成了一个原子操作，执行期间不会被打断。当线程 A 执行 &lt;code&gt;TestAndSet&lt;/code&gt;  原语时，会把 &lt;code&gt;lock-&amp;gt;flag&lt;/code&gt;  设置为 1，并返回之前的值。若返回值是 0，那么线程 A 就可以退出 &lt;code&gt;while&lt;/code&gt; ，此时若线程 B 也进入 &lt;code&gt;while&lt;/code&gt; ，由于 &lt;code&gt;TestAndSet&lt;/code&gt;  原语已把 &lt;code&gt;lock-&amp;gt;flag&lt;/code&gt;  设置为 1，线程 B 无法退出 &lt;code&gt;while&lt;/code&gt; ，也就不会出现有多个线程同时拿到同一把锁的情况。&lt;/p&gt;
&lt;h3 id=&#34;22&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#22&#34;&gt;#&lt;/a&gt; 2.2&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;假设系统中有 2 个线程 X 和 Y（优先级相同），它们之间通过 “CPU 时间片轮转调度策略” 来分享底层唯一的一个 CPU 资源。其中，X 在某个时刻通过图 3 的 lock () 获取到了锁，并且需要运行 10 个时间片才会调用 unlock () 来释放锁。请问，在此时间段内，Y 会分到时间片吗？如果可以分到，那么 Y 是个什么运行形态？此运行形态会带来什么样的负面效果？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答：Y 会分到时间片。按照时间片轮转调度策略，X 的时间片结束之后，就会被移动到就绪队列尾部，这时 Y 分到时间片并开始执行，但是锁还被 X 占据，所以 Y 即使分到了时间片，也只能一直停留在 &lt;code&gt;while&lt;/code&gt;  中，直到 Y 的时间片结束，然后轮到 X 继续执行…… 实际上 Y 除了循环判断 &lt;code&gt;lock-&amp;gt;flag&lt;/code&gt; ，并没有做什么有用的工作。这样的运行形态会使得 CPU 运行效率变得比较低，因为 Y 实际上并没有做什么工作，造成资源浪费。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;基于linux的futex锁&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#基于linux的futex锁&#34;&gt;#&lt;/a&gt; 基于 Linux 的 Futex 锁&lt;/h2&gt;
&lt;p&gt;以下是基于 Linux 的 Futex 锁实现方式：&lt;/p&gt;
&lt;figure class=&#34;highlight c++&#34;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&#34;gutter hljs&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;span class=&#34;line&#34;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;20&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;21&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;22&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;23&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;24&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;25&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;26&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;27&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;28&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;29&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;line&#34;&gt;30&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class=&#34;code&#34;&gt;&lt;div class=&#34;hljs code-wrapper&#34;&gt;&lt;pre&gt;&lt;code class=&#34;hljs c++&#34;&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;mutex_lock&lt;/span&gt; &lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; *mutex)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;br&gt;	&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; v;&lt;br&gt;	&lt;span class=&#34;hljs-comment&#34;&gt;/* Bit 31 was clear, we got the mutex (this is the fastpath) */&lt;/span&gt;&lt;br&gt;	&lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (&lt;span class=&#34;hljs-built_in&#34;&gt;atomic_bit_test_set&lt;/span&gt; (mutex, &lt;span class=&#34;hljs-number&#34;&gt;31&lt;/span&gt;) == &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;)&lt;br&gt;     	&lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt;;&lt;br&gt;	&lt;span class=&#34;hljs-built_in&#34;&gt;atomic_increment&lt;/span&gt; (mutex);&lt;br&gt;	&lt;span class=&#34;hljs-keyword&#34;&gt;while&lt;/span&gt; (&lt;span class=&#34;hljs-number&#34;&gt;1&lt;/span&gt;) &amp;#123;&lt;br&gt; 		&lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (&lt;span class=&#34;hljs-built_in&#34;&gt;atomic_bit_test_set&lt;/span&gt; (mutex, &lt;span class=&#34;hljs-number&#34;&gt;31&lt;/span&gt;) == &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;) &amp;#123;&lt;br&gt; 			&lt;span class=&#34;hljs-built_in&#34;&gt;atomic_decrement&lt;/span&gt; (mutex);&lt;br&gt; 			&lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt;;&lt;br&gt; 		&amp;#125;&lt;br&gt; 		&lt;span class=&#34;hljs-comment&#34;&gt;/* We have to wait now. First make sure the futex value&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt; 		We are monitoring is truly negative (i.e. locked). */&lt;/span&gt;&lt;br&gt; 		v = *mutex;&lt;br&gt; 		&lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (v &amp;gt;= &lt;span class=&#34;hljs-number&#34;&gt;0&lt;/span&gt;)&lt;br&gt;			&lt;span class=&#34;hljs-keyword&#34;&gt;continue&lt;/span&gt;;&lt;br&gt; 		&lt;span class=&#34;hljs-built_in&#34;&gt;futex_wait&lt;/span&gt; (mutex, v);&lt;br&gt; 	&amp;#125;&lt;span class=&#34;hljs-comment&#34;&gt;/*end while*/&lt;/span&gt;&lt;br&gt;&amp;#125;&lt;br&gt;&lt;br&gt;&lt;span class=&#34;hljs-function&#34;&gt;&lt;span class=&#34;hljs-keyword&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;hljs-title&#34;&gt;mutex_unlock&lt;/span&gt; &lt;span class=&#34;hljs-params&#34;&gt;(&lt;span class=&#34;hljs-keyword&#34;&gt;int&lt;/span&gt; *mutex)&lt;/span&gt; &lt;/span&gt;&amp;#123;&lt;br&gt;	&lt;span class=&#34;hljs-comment&#34;&gt;/* Adding 0x80000000 to the counter results in 0 if and only if&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;     there are not other interested threads */&lt;/span&gt;&lt;br&gt;     &lt;span class=&#34;hljs-keyword&#34;&gt;if&lt;/span&gt; (&lt;span class=&#34;hljs-built_in&#34;&gt;atomic_add_zero&lt;/span&gt; (mutex, &lt;span class=&#34;hljs-number&#34;&gt;0x80000000&lt;/span&gt;))&lt;br&gt;         &lt;span class=&#34;hljs-keyword&#34;&gt;return&lt;/span&gt;;&lt;br&gt;&lt;br&gt;     &lt;span class=&#34;hljs-comment&#34;&gt;/* There are other threads waiting for this mutex,&lt;/span&gt;&lt;br&gt;&lt;span class=&#34;hljs-comment&#34;&gt;     wake one of them up. */&lt;/span&gt;&lt;br&gt;     &lt;span class=&#34;hljs-built_in&#34;&gt;futex_wake&lt;/span&gt; (mutex);&lt;br&gt;&amp;#125;&lt;br&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h3 id=&#34;31&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#31&#34;&gt;#&lt;/a&gt; 3.1&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;该图中的第 4～5 行，和图中的第 8～11 行，具体实现什么作用？它们是否有功 能冗余和冲突？可以去掉当中的一个吗？为什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;4-5 行：判断锁是否被占用并置 1，若能获取锁，则直接退出 &lt;code&gt;mutex_lock()&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;8-11 行：被 &lt;code&gt;futex_wait&lt;/code&gt;  的线程被 &lt;code&gt;futex_wake&lt;/code&gt;  唤醒后，判断能否获取锁，若能则占用锁并退出 &lt;code&gt;while&lt;/code&gt; 。&lt;/li&gt;
&lt;li&gt;不能去掉任何一个。对于 4-5 行，若能直接获取锁，则无需被 &lt;code&gt;wait&lt;/code&gt; ；若去掉 8-11 行，则被 &lt;code&gt;wake&lt;/code&gt;  后也无法跳出 &lt;code&gt;while&lt;/code&gt; 。这两段代码是配合 &lt;code&gt;atomic_increment&lt;/code&gt;  和 &lt;code&gt;atomic_decrement&lt;/code&gt;  使用的，能够统计在等待的线程数，缺一不可。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;32&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#32&#34;&gt;#&lt;/a&gt; 3.2&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;在第 24～25 行中的 if 语句是用来干什么的？如果条件语句 atomic_add_zero (mutex, 0x80000000) 为真，为什么要直接 return，为什么不直接执行第 29 行程序呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;if&lt;/code&gt;  语句是为了确保锁可用时，不会执行 &lt;code&gt;wait&lt;/code&gt; 。假设没有 &lt;code&gt;if&lt;/code&gt;  语句，A 没有获取到锁，在 A 执行 &lt;code&gt;wait&lt;/code&gt;  之前，B 执行了 &lt;code&gt;unlock&lt;/code&gt; ，此时 &lt;code&gt;atomic_add_zero&lt;/code&gt;  返回 &lt;code&gt;true&lt;/code&gt; ，也就不会执行 &lt;code&gt;wake&lt;/code&gt; ，然后 A 执行了 &lt;code&gt;wait&lt;/code&gt; ，此时如果没有新的线程加入，那么 A 就永远不会被唤醒。&lt;/li&gt;
&lt;li&gt;如果条件语句 &lt;code&gt;atomic_add_zero (mutex, 0x80000000)&lt;/code&gt;  为真，说明在等待的线程数为 0，没有线程需要被 &lt;code&gt;wake&lt;/code&gt; ，直接 &lt;code&gt;return&lt;/code&gt;  能提高效率。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3 id=&#34;33&#34;&gt;&lt;a class=&#34;markdownIt-Anchor&#34; href=&#34;#33&#34;&gt;#&lt;/a&gt; 3.3&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;Futex 锁实现方式是否改进了 2.2 问题中提到的负面效果，为什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;答：改进了 2.2 问题中的负面效果， &lt;code&gt;futex_wait&lt;/code&gt;  可以让正在执行但没有获得锁的线程睡眠，让出 CPU 给别的线程，避免了无用的等待，能提高 CPU 的使用效率。&lt;/p&gt;
</content>
        <category term="Linux" />
        <category term="锁" />
        <updated>2021-12-11T15:45:14.000Z</updated>
    </entry>
</feed>
