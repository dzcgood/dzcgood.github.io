{
    "version": "https://jsonfeed.org/version/1",
    "title": "DzcGood • All posts by \"锁\" tag",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2021/12/11/Lock/",
            "url": "http://example.com/2021/12/11/Lock/",
            "title": "锁",
            "date_published": "2021-12-11T15:45:14.000Z",
            "content_html": "<h1 id=\"锁\"><a class=\"markdownIt-Anchor\" href=\"#锁\">#</a> 锁</h1>\n<h2 id=\"基于标志的锁\"><a class=\"markdownIt-Anchor\" href=\"#基于标志的锁\">#</a> 基于标志的锁</h2>\n<p>以下是基于标志（flag）的锁的实现方式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> __<span class=\"hljs-title\">lock_t</span> &#123;</span><span class=\"hljs-keyword\">int</span> flag;&#125; <span class=\"hljs-keyword\">lock_t</span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">lock_t</span> *mutex)</span></span>&#123;<br>    <span class=\"hljs-comment\">// 0 -&gt; lock is available, 1 -&gt; held</span><br>    mutex -&gt; flag = <span class=\"hljs-number\">0</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">lock</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">lock_t</span> *mutex)</span></span>&#123;<br>    <span class=\"hljs-keyword\">while</span>(mutex -&gt; flag == <span class=\"hljs-number\">1</span>) <span class=\"hljs-comment\">// TEST the flag</span><br>        ;<span class=\"hljs-comment\">// spin-wait(do nothing)</span><br>    mutex -&gt; flag = <span class=\"hljs-number\">1</span>;<br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">unlock</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">lock_t</span> *mutex)</span></span>&#123;<br>    mutex -&gt; flag = <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n<h3 id=\"11\"><a class=\"markdownIt-Anchor\" href=\"#11\">#</a> 1.1</h3>\n<blockquote>\n<p>第 10 行的注释，spin-wait，是什么意思？</p>\n</blockquote>\n<p>答： <code>spin-wait</code>  是指自旋等待， <code>flag</code>  为 1 时，线程反复检查锁变量是否可用； <code>flag</code>  为 0 时，说明锁变量可用，设置 <code>flag</code>  为 1 表示保持该锁。</p>\n<h3 id=\"12\"><a class=\"markdownIt-Anchor\" href=\"#12\">#</a> 1.2</h3>\n<blockquote>\n<p>假设没有底层硬件或者操作系统的相关支持，该锁用于进程间的互斥，则其实现方式会有什么问题？请详细说明。</p>\n</blockquote>\n<p>答：获取、释放锁，实际上是读写存储内存或寄存器，因此这种读写操作必须是原子的。如果没有底层硬件或者操作系统的支持，那么就无法保证其操作的原子性。对于 <code>lock函数</code> ， <code>flag</code>  检测和设置本该是一体的，但由于无法保证原子性，那么 <code>while</code>  和 <code>mutex -&gt; flag = 1</code>  之间就可能混入其他线程的操作，例如线程 A 执行到 <code>mutex-&gt;flag = 1</code>  语句之前，另一个线程 B 运行到 <code>while</code> ，由于 <code>mutex-&gt;flag</code>  还未被赋值为 1，线程 B 也可以跳出 <code>while</code> ，于是线程 A 和 B 都拿到了这把锁。</p>\n<hr>\n<h2 id=\"基于test-and-set原子指令的锁\"><a class=\"markdownIt-Anchor\" href=\"#基于test-and-set原子指令的锁\">#</a> 基于 Test-and-Set 原子指令的锁</h2>\n<p>以下是 <code>Test-and-Set</code>  原子指令的实现逻辑：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">TestAndSet</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> *old_ptr, <span class=\"hljs-keyword\">int</span> <span class=\"hljs-keyword\">new</span>)</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> old = *old_ptr;\t<span class=\"hljs-comment\">//fetch old value at old_ptr</span><br> \t*old_ptr = <span class=\"hljs-keyword\">new</span>;\t<span class=\"hljs-comment\">//store ‘new’ into old_ptr</span><br> \t<span class=\"hljs-keyword\">return</span> old;\t<span class=\"hljs-comment\">//return the old value</span><br>&#125;<br></code></pre></div></td></tr></table></figure>\n<p>以下是基于  <code>Test-and-Set</code>  指令的锁实现方式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-keyword\">typedef</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> __<span class=\"hljs-title\">lock_t</span> &#123;</span><br> \t<span class=\"hljs-keyword\">int</span> flag;<br>&#125; <span class=\"hljs-keyword\">lock_t</span>;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">lock_t</span> *lock)</span> </span>&#123;<br>\t<span class=\"hljs-comment\">// 0 indicates that lock is available, 1 that it is held</span><br>\tlock-&gt;flag = <span class=\"hljs-number\">0</span>;<br>&#125;<br><br> <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">lock</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">lock_t</span> *lock)</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-built_in\">TestAndSet</span>(&amp;lock-&gt;flag, <span class=\"hljs-number\">1</span>) == <span class=\"hljs-number\">1</span>)<br>\t; <span class=\"hljs-comment\">// spin-wait (do nothing)</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">unlock</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">lock_t</span> *lock)</span> </span>&#123;<br>\tlock-&gt;flag = <span class=\"hljs-number\">0</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure>\n<h3 id=\"21\"><a class=\"markdownIt-Anchor\" href=\"#21\">#</a> 2.1</h3>\n<blockquote>\n<p>&quot;基于 Test-and-Set&quot; 指令的锁实现方式，是否可以解决 1.2 中，“基于标志 （flag）的锁实现方式” 所存在的问题，为什么？</p>\n</blockquote>\n<p>答：可以。“返回旧值” 和 “设置新值” 这两个操作共同组成了一个原子操作，执行期间不会被打断。当线程 A 执行 <code>TestAndSet</code>  原语时，会把 <code>lock-&gt;flag</code>  设置为 1，并返回之前的值。若返回值是 0，那么线程 A 就可以退出 <code>while</code> ，此时若线程 B 也进入 <code>while</code> ，由于 <code>TestAndSet</code>  原语已把 <code>lock-&gt;flag</code>  设置为 1，线程 B 无法退出 <code>while</code> ，也就不会出现有多个线程同时拿到同一把锁的情况。</p>\n<h3 id=\"22\"><a class=\"markdownIt-Anchor\" href=\"#22\">#</a> 2.2</h3>\n<blockquote>\n<p>假设系统中有 2 个线程 X 和 Y（优先级相同），它们之间通过 “CPU 时间片轮转调度策略” 来分享底层唯一的一个 CPU 资源。其中，X 在某个时刻通过图 3 的 lock () 获取到了锁，并且需要运行 10 个时间片才会调用 unlock () 来释放锁。请问，在此时间段内，Y 会分到时间片吗？如果可以分到，那么 Y 是个什么运行形态？此运行形态会带来什么样的负面效果？</p>\n</blockquote>\n<p>答：Y 会分到时间片。按照时间片轮转调度策略，X 的时间片结束之后，就会被移动到就绪队列尾部，这时 Y 分到时间片并开始执行，但是锁还被 X 占据，所以 Y 即使分到了时间片，也只能一直停留在 <code>while</code>  中，直到 Y 的时间片结束，然后轮到 X 继续执行…… 实际上 Y 除了循环判断 <code>lock-&gt;flag</code> ，并没有做什么有用的工作。这样的运行形态会使得 CPU 运行效率变得比较低，因为 Y 实际上并没有做什么工作，造成资源浪费。</p>\n<hr>\n<h2 id=\"基于linux的futex锁\"><a class=\"markdownIt-Anchor\" href=\"#基于linux的futex锁\">#</a> 基于 Linux 的 Futex 锁</h2>\n<p>以下是基于 Linux 的 Futex 锁实现方式：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">mutex_lock</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> *mutex)</span> </span>&#123;<br>\t<span class=\"hljs-keyword\">int</span> v;<br>\t<span class=\"hljs-comment\">/* Bit 31 was clear, we got the mutex (this is the fastpath) */</span><br>\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">atomic_bit_test_set</span> (mutex, <span class=\"hljs-number\">31</span>) == <span class=\"hljs-number\">0</span>)<br>     \t<span class=\"hljs-keyword\">return</span>;<br>\t<span class=\"hljs-built_in\">atomic_increment</span> (mutex);<br>\t<span class=\"hljs-keyword\">while</span> (<span class=\"hljs-number\">1</span>) &#123;<br> \t\t<span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">atomic_bit_test_set</span> (mutex, <span class=\"hljs-number\">31</span>) == <span class=\"hljs-number\">0</span>) &#123;<br> \t\t\t<span class=\"hljs-built_in\">atomic_decrement</span> (mutex);<br> \t\t\t<span class=\"hljs-keyword\">return</span>;<br> \t\t&#125;<br> \t\t<span class=\"hljs-comment\">/* We have to wait now. First make sure the futex value</span><br><span class=\"hljs-comment\"> \t\tWe are monitoring is truly negative (i.e. locked). */</span><br> \t\tv = *mutex;<br> \t\t<span class=\"hljs-keyword\">if</span> (v &gt;= <span class=\"hljs-number\">0</span>)<br>\t\t\t<span class=\"hljs-keyword\">continue</span>;<br> \t\t<span class=\"hljs-built_in\">futex_wait</span> (mutex, v);<br> \t&#125;<span class=\"hljs-comment\">/*end while*/</span><br>&#125;<br><br><span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">mutex_unlock</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> *mutex)</span> </span>&#123;<br>\t<span class=\"hljs-comment\">/* Adding 0x80000000 to the counter results in 0 if and only if</span><br><span class=\"hljs-comment\">     there are not other interested threads */</span><br>     <span class=\"hljs-keyword\">if</span> (<span class=\"hljs-built_in\">atomic_add_zero</span> (mutex, <span class=\"hljs-number\">0x80000000</span>))<br>         <span class=\"hljs-keyword\">return</span>;<br><br>     <span class=\"hljs-comment\">/* There are other threads waiting for this mutex,</span><br><span class=\"hljs-comment\">     wake one of them up. */</span><br>     <span class=\"hljs-built_in\">futex_wake</span> (mutex);<br>&#125;<br></code></pre></div></td></tr></table></figure>\n<h3 id=\"31\"><a class=\"markdownIt-Anchor\" href=\"#31\">#</a> 3.1</h3>\n<blockquote>\n<p>该图中的第 4～5 行，和图中的第 8～11 行，具体实现什么作用？它们是否有功 能冗余和冲突？可以去掉当中的一个吗？为什么？</p>\n</blockquote>\n<p>答：</p>\n<ul>\n<li>4-5 行：判断锁是否被占用并置 1，若能获取锁，则直接退出 <code>mutex_lock()</code> 。</li>\n<li>8-11 行：被 <code>futex_wait</code>  的线程被 <code>futex_wake</code>  唤醒后，判断能否获取锁，若能则占用锁并退出 <code>while</code> 。</li>\n<li>不能去掉任何一个。对于 4-5 行，若能直接获取锁，则无需被 <code>wait</code> ；若去掉 8-11 行，则被 <code>wake</code>  后也无法跳出 <code>while</code> 。这两段代码是配合 <code>atomic_increment</code>  和 <code>atomic_decrement</code>  使用的，能够统计在等待的线程数，缺一不可。</li>\n</ul>\n<h3 id=\"32\"><a class=\"markdownIt-Anchor\" href=\"#32\">#</a> 3.2</h3>\n<blockquote>\n<p>在第 24～25 行中的 if 语句是用来干什么的？如果条件语句 atomic_add_zero (mutex, 0x80000000) 为真，为什么要直接 return，为什么不直接执行第 29 行程序呢？</p>\n</blockquote>\n<p>答：</p>\n<ul>\n<li><code>if</code>  语句是为了确保锁可用时，不会执行 <code>wait</code> 。假设没有 <code>if</code>  语句，A 没有获取到锁，在 A 执行 <code>wait</code>  之前，B 执行了 <code>unlock</code> ，此时 <code>atomic_add_zero</code>  返回 <code>true</code> ，也就不会执行 <code>wake</code> ，然后 A 执行了 <code>wait</code> ，此时如果没有新的线程加入，那么 A 就永远不会被唤醒。</li>\n<li>如果条件语句 <code>atomic_add_zero (mutex, 0x80000000)</code>  为真，说明在等待的线程数为 0，没有线程需要被 <code>wake</code> ，直接 <code>return</code>  能提高效率。</li>\n</ul>\n<h3 id=\"33\"><a class=\"markdownIt-Anchor\" href=\"#33\">#</a> 3.3</h3>\n<blockquote>\n<p>Futex 锁实现方式是否改进了 2.2 问题中提到的负面效果，为什么？</p>\n</blockquote>\n<p>答：改进了 2.2 问题中的负面效果， <code>futex_wait</code>  可以让正在执行但没有获得锁的线程睡眠，让出 CPU 给别的线程，避免了无用的等待，能提高 CPU 的使用效率。</p>\n",
            "tags": [
                "Linux",
                "锁"
            ]
        }
    ]
}