{
    "version": "https://jsonfeed.org/version/1",
    "title": "DzcGood • All posts by \"编译原理\" category",
    "description": "",
    "home_page_url": "http://example.com",
    "items": [
        {
            "id": "http://example.com/2021/11/26/GrammerProblemProcessor/",
            "url": "http://example.com/2021/11/26/GrammerProblemProcessor/",
            "title": "文法问题处理器",
            "date_published": "2021-11-26T08:15:00.000Z",
            "content_html": "<h1 id=\"文法问题处理器\"><a class=\"markdownIt-Anchor\" href=\"#文法问题处理器\">#</a> 文法问题处理器</h1>\n<h2 id=\"问题描述\"><a class=\"markdownIt-Anchor\" href=\"#问题描述\">#</a> 问题描述</h2>\n<p>设计一个文法规则处理器，使其能够实现以下功能：</p>\n<ul>\n<li>检查并去除有害规则和多余规则</li>\n<li>消除该文法的左公共因子</li>\n<li>消除该文法的左递归</li>\n<li>求出经过前面步骤处理好的文法各非终结符号的 first 集合与 follow 集合</li>\n<li>对输入的句子进行最左推导分析</li>\n<li>使用符号’@‘代表’ε’</li>\n</ul>\n<h2 id=\"系统流程图\"><a class=\"markdownIt-Anchor\" href=\"#系统流程图\">#</a> 系统流程图</h2>\n<p><img src=\"https://gitee.com/dzcgood/img-bed/raw/master/img/%E6%B5%81%E7%A8%8B%E5%9B%BE.jpg\" alt=\"系统流程图\"></p>\n<h2 id=\"存储结构设计\"><a class=\"markdownIt-Anchor\" href=\"#存储结构设计\">#</a> 存储结构设计</h2>\n<h3 id=\"文法规则存储结构\"><a class=\"markdownIt-Anchor\" href=\"#文法规则存储结构\">#</a> 文法规则存储结构</h3>\n<p>对于一条文法规则，使用 string 来存储左边部分，用 vector&lt;vector&lt;string&gt;&gt; 来存储右边部分。</p>\n<p>例如：对于文法规则 A -&gt; acd | efg | hig，则右边部分的存储结构为 [[a, c, d], [e, f, g], [h, i, g]]</p>\n<p>类声明如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//使用&#x27;@&#x27;标识EPSILON</span><br><span class=\"hljs-meta\">#<span class=\"hljs-meta-keyword\">define</span> EPSILON <span class=\"hljs-meta-string\">&quot;@&quot;</span></span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">LinkNode</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">//规则左部</span><br>    string left;<br>    <span class=\"hljs-comment\">//规则右部分 abc | def | hji，一个vector&lt;char&gt;元素代表一种可能</span><br>    vector&lt;vector&lt;string&gt;&gt; right;<br>    <span class=\"hljs-comment\">//构造函数，str是左边部分</span><br>    <span class=\"hljs-built_in\">LinkNode</span>(string str);<br>    <span class=\"hljs-comment\">//右边添加规则</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(vector&lt;string&gt; &amp;nodes)</span></span>;<br>    <span class=\"hljs-comment\">//判断是否有epsilon存在</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">includesEpsilon</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-comment\">//toString()方法</span><br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">toString</span><span class=\"hljs-params\">()</span></span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n<h3 id=\"文法处理器存储结构\"><a class=\"markdownIt-Anchor\" href=\"#文法处理器存储结构\">#</a> 文法处理器存储结构</h3>\n<p>文法处理器的功能包括对文法的存储以及各种处理操作。</p>\n<ul>\n<li>使用 vector&lt;LinkNode&gt; 存储多条文法规则</li>\n<li>使用 vector&lt;string&gt; 存储用户输入的待推导句子、终结符号、非终结符号</li>\n<li>使用 map&lt;string, set&lt;string&gt;&gt; 存储各个非终结符号对应的 first 集合和 follow 集合</li>\n</ul>\n<p>类声明如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Processor</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    vector&lt;string&gt;input;<span class=\"hljs-comment\">//存用户输入的待分析句子</span><br>    <span class=\"hljs-keyword\">int</span> startWordIndex;<span class=\"hljs-comment\">//开始节点索引    </span><br>    string startNode;<span class=\"hljs-comment\">//开始结点值   </span><br>    vector&lt;LinkNode&gt; grammers;<span class=\"hljs-comment\">//存文法   </span><br>    vector&lt;string&gt; finalWord;<span class=\"hljs-comment\">//终结符号</span><br>    vector&lt;string&gt; nonFinalWord;<span class=\"hljs-comment\">//非终结符号   </span><br>    map&lt;string, set&lt;string&gt;&gt; first;<span class=\"hljs-comment\">//First集合   </span><br>    map&lt;string, set&lt;string&gt;&gt; follow;<span class=\"hljs-comment\">//Follow集合   </span><br>    ofstream log;<span class=\"hljs-comment\">//文件流，用于写出日志   </span><br>    <span class=\"hljs-built_in\">Processor</span>(string filePath);<span class=\"hljs-comment\">//构造函数，参数是文件路径 </span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">init</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//初始化终结符号和非终结符号    </span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dealLeftRecursion</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//处理左递归   </span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dealLeftCommonFacotr</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//处理左公因子 </span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">simplify</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//化简 </span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">getFirst</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//生成First集合   </span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">getFollow</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//生成Follow集合   </span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">isFinalWord</span><span class=\"hljs-params\">(string word)</span></span>;<span class=\"hljs-comment\">//判断是不是终结符号  </span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">isWord</span><span class=\"hljs-params\">(string word)</span></span>;<span class=\"hljs-comment\">//判断是不是该文法能处理的符号</span><br>    <span class=\"hljs-comment\">//按照指定符号拆分字符串</span><br>    <span class=\"hljs-function\">vector&lt;string&gt; <span class=\"hljs-title\">splitString</span><span class=\"hljs-params\">(string str, string spliter)</span></span>;  <br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">printGrammers</span><span class=\"hljs-params\">()</span></span>;<span class=\"hljs-comment\">//输出当前文法信息到log文件   </span><br>    vector&lt;vector&lt;string&gt;&gt; <span class=\"hljs-built_in\">leftMostDerivation</span>();<span class=\"hljs-comment\">//最左推导</span><br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-comment\">//用于存储是否访问过</span><br>    <span class=\"hljs-keyword\">bool</span> visited[MAX_NODE_NUMBER];<br>    <span class=\"hljs-comment\">//找到非终结符号word对应的是第几条规则</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getIndex</span><span class=\"hljs-params\">(string word)</span></span>;<br>    <span class=\"hljs-comment\">//配合getFirst()函数使用，递归实现求某条规则的first集合</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">findFirst</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> i)</span></span>;<br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">dfs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> x)</span></span>;<span class=\"hljs-comment\">//深度优先遍历</span><br>    <span class=\"hljs-comment\">//处理单条文法的左公因子</span><br>    <span class=\"hljs-function\">vector&lt;LinkNode&gt; <span class=\"hljs-title\">dealCommonFactor</span><span class=\"hljs-params\">(LinkNode&amp;node)</span></span>;<br>    <span class=\"hljs-comment\">//生成一个没有使用过的非终结符号名</span><br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">generateNewName</span><span class=\"hljs-params\">(string source)</span></span>;<br>    <span class=\"hljs-comment\">//将str1的follow添加到str2的follow集合</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">append</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> string &amp;str1, <span class=\"hljs-keyword\">const</span> string &amp;str2)</span></span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n<p>##UI 设计</p>\n<h3 id=\"读取文法并做处理的界面\"><a class=\"markdownIt-Anchor\" href=\"#读取文法并做处理的界面\">#</a> 读取文法并做处理的界面</h3>\n<p><img src=\"https://gitee.com/dzcgood/img-bed/raw/master/img/image-20211126170426459.png\" alt=\"读取文法并做处理的界面\"></p>\n<h3 id=\"最左推导界面\"><a class=\"markdownIt-Anchor\" href=\"#最左推导界面\">#</a> 最左推导界面</h3>\n<p><img src=\"https://gitee.com/dzcgood/img-bed/raw/master/img/image-20211126170501759.png\" alt=\"最左推导界面\"></p>\n<h2 id=\"主要算法说明\"><a class=\"markdownIt-Anchor\" href=\"#主要算法说明\">#</a> 主要算法说明</h2>\n<h3 id=\"去除无效文法\"><a class=\"markdownIt-Anchor\" href=\"#去除无效文法\">#</a> 去除无效文法</h3>\n<ul>\n<li>对于形如 A -&gt; A 的有害规则，在读取规则时就可以将其去除</li>\n<li>对于直接或间接无法终止的规则，暂时没想好怎么处理……</li>\n<li>对于用不到的无效规则，可以采用深度优先的方法，设置一个 bool 数组用于标记是否访问过各条文法规则，从开始结点遍历文法规则，当遍历结束时，对于没有访问过的文法规则，就将其删除</li>\n</ul>\n<p><img src=\"https://gitee.com/dzcgood/img-bed/raw/master/img/%E5%8E%BB%E9%99%A4%E5%A4%9A%E4%BD%99%E8%A7%84%E5%88%99.jpg\" alt=\"去除多余规则\"></p>\n<h3 id=\"去除左递归\"><a class=\"markdownIt-Anchor\" href=\"#去除左递归\">#</a> 去除左递归</h3>\n<ul>\n<li>先将文法右边的非终结符号用其对应的转换规则取代，例如：S -&gt; Qc | c，R -&gt; Sa | a，Q -&gt; Rb | b，就先把 S 带入 R，然后把 R 带入 Q 中，这种做法可以使得间接的左递归也转化成直接左递归</li>\n<li>然后再开始消除直接左递归，例如 A -&gt; Aa|b，就转换成 A -&gt; bA‘，A’ -&gt; aA’ | ε</li>\n</ul>\n<p><img src=\"https://gitee.com/dzcgood/img-bed/raw/master/img/%E5%8E%BB%E9%99%A4%E5%B7%A6%E9%80%92%E5%BD%92.jpg\" alt=\"去除左递归\"></p>\n<h3 id=\"去除左公因子\"><a class=\"markdownIt-Anchor\" href=\"#去除左公因子\">#</a> 去除左公因子</h3>\n<p>处理的思路是每次只寻找一个左公因子</p>\n<ul>\n<li>例如 A -&gt; ab | abc</li>\n<li>第一次处理后变成 A -&gt; aA’，A’ -&gt; b | bc</li>\n<li>第二次处理后变成 A -&gt; aA’，A‘ -&gt; bA’’，A’‘ -&gt; ε | c</li>\n</ul>\n<p>定义从调函数，其功能是对于某条文法规则，若有左公因子，就返回处理好后的（一条变多条）文法规则，若没有左公因子，就返回一个空的 vector；定义一个主调函数，定义变量 i，当 i 小于文法数量时，就一直执行从调函数，若从调函数返回的向量为空，就说明此文法规则无左公因子，那么 i++，否则就将目前处理的文法规则替换为从调函数返回的（多条）文法规则</p>\n<p>因为逻辑比较复杂，所以流程图化的有点乱</p>\n<p><img src=\"https://gitee.com/dzcgood/img-bed/raw/master/img/%E6%8F%90%E5%8F%96%E5%B7%A6%E5%85%AC%E5%9B%A0%E5%AD%90.jpg\" alt=\"提取左公因子\"></p>\n<h3 id=\"求first集合\"><a class=\"markdownIt-Anchor\" href=\"#求first集合\">#</a> 求 first 集合</h3>\n<p>对于规则 X -&gt; x1x2…xn，first (x) 的计算方法如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">first</span>(X) = &#123;&#125;<br>k = <span class=\"hljs-number\">1</span><br><span class=\"hljs-keyword\">while</span>(k &lt;= n)<br>&#123;<br>\t<span class=\"hljs-keyword\">if</span>(xk为终结符号或ε)<br>        <span class=\"hljs-built_in\">first</span>(xk) = xk;<br>    <span class=\"hljs-built_in\">first</span>(x) = <span class=\"hljs-built_in\">first</span>(x) ∪ <span class=\"hljs-built_in\">first</span>(xk) - &#123;ε&#125;;<br>    <span class=\"hljs-keyword\">if</span>(ε 不属于 <span class=\"hljs-built_in\">first</span>(xk))<br>        <span class=\"hljs-keyword\">break</span>;<br>    k++;<br>&#125; <br><span class=\"hljs-keyword\">if</span>(k == n + <span class=\"hljs-number\">1</span>)<br>    <span class=\"hljs-built_in\">first</span>(x) += &#123;ε&#125;;<br></code></pre></div></td></tr></table></figure>\n<p><img src=\"https://gitee.com/dzcgood/img-bed/raw/master/img/%E6%B1%82first%E9%9B%86%E5%90%88.jpg\" alt=\"求first集合\"></p>\n<p>### 求 follow 集合</p>\n<p>计算 follow 集合的算法如下：</p>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-built_in\">follow</span>(开始符号) = &#123;$&#125;<br>其他任何一个非终结符号A，则执行<span class=\"hljs-built_in\">follow</span>(A) = &#123;&#125;<br><span class=\"hljs-keyword\">while</span>(有follow集合在变化)<br>    循环：对每条文法规则A -&gt; X1X2...Xn都执行<br>    \t对于每个非终结符号Xi，都执行<br>    \t\t把<span class=\"hljs-built_in\">first</span>(Xi+<span class=\"hljs-number\">1</span>Xi+<span class=\"hljs-number\">2.</span>..Xn)-&#123;ε&#125;添加到<span class=\"hljs-built_in\">follow</span>(Xi)<br>    \t\t<span class=\"hljs-keyword\">if</span>(ε in <span class=\"hljs-built_in\">first</span>(Xi+<span class=\"hljs-number\">1</span>Xi+<span class=\"hljs-number\">2.</span>..Xn))<br>                把<span class=\"hljs-built_in\">follow</span>(A)添加到<span class=\"hljs-built_in\">follow</span>(Xi)<br></code></pre></div></td></tr></table></figure>\n<p><img src=\"C:/Users/DzcGood/Desktop/%E6%B1%82follow%E9%9B%86%E5%90%88.jpg\" alt=\"求follow集合\"></p>\n<p>### 最左推导</p>\n<p>设计一个计数器，表示当前匹配到第几个字符。从开始符号开始执行，每次执行找到当前已生成符号串从左到右第一个非终结符号，查看该终结符号的文法规则：</p>\n<ul>\n<li>若第一个字符是终结符号，且和待匹配字符相同，就选择该转换</li>\n<li>若第一个字符是非终结符号，且 first 集合包含待匹配字符，就选择该转换</li>\n<li>若第一个字符是非终结符号，且 follow 集合包含待匹配字符，就选择 ε 转换</li>\n</ul>\n<p><img src=\"https://gitee.com/dzcgood/img-bed/raw/master/img/%E6%9C%80%E5%B7%A6%E6%8E%A8%E5%AF%BC.jpg\" alt=\"最左推导\"></p>\n<p>## 其他说明</p>\n<p>本文法问题处理器对于以下集中情况暂时无法处理，有待后续改进：</p>\n<ul>\n<li>直接或间接无法终止的文法规则，目前想到的处理思路是当递归深度超过一定程度时就报错，但是具体实现的时候遇到了问题</li>\n<li>输入时或处理后出现某条文法规则可以变成’ε’，且 first 和 follow 集合的交集不为空的情况，这个暂时想不到好的办法解决。</li>\n</ul>\n",
            "tags": [
                "编译原理",
                "SCNU-CS"
            ]
        },
        {
            "id": "http://example.com/2021/10/31/XLEX_Generator/",
            "url": "http://example.com/2021/10/31/XLEX_Generator/",
            "title": "编译原理实验二 XLEX",
            "date_published": "2021-10-31T06:33:54.000Z",
            "content_html": "<h1 id=\"xlex软件文档\"><a class=\"markdownIt-Anchor\" href=\"#xlex软件文档\">#</a> XLEX 软件文档</h1>\n<h2 id=\"关于\"><a class=\"markdownIt-Anchor\" href=\"#关于\">#</a> 关于</h2>\n<blockquote>\n<p>SCNU-CS 编译原理实验二，本来想好好写一写的，但是时间紧迫，先水一水吧，以后有时间再改一改。（还有 bug 没改）</p>\n</blockquote>\n<h2 id=\"作者\"><a class=\"markdownIt-Anchor\" href=\"#作者\">#</a> 作者</h2>\n<blockquote>\n<p><a href = https://github.com/dzcgood>@dzcgood</a></p>\n</blockquote>\n<h2 id=\"开发环境\"><a class=\"markdownIt-Anchor\" href=\"#开发环境\">#</a> 开发环境</h2>\n<blockquote>\n<p>Qt Creator 4.11.1(Community)</p>\n</blockquote>\n<h2 id=\"顶层程序流程图\"><a class=\"markdownIt-Anchor\" href=\"#顶层程序流程图\">#</a> 顶层程序流程图</h2>\n<p><img src=\"/img/%E9%A1%B6%E5%B1%82%E6%B5%81%E7%A8%8B%E5%9B%BE.png\" alt=\"顶层流程图\"></p>\n<h2 id=\"实现思路\"><a class=\"markdownIt-Anchor\" href=\"#实现思路\">#</a> 实现思路</h2>\n<h3 id=\"this-nfa-选择\"><a class=\"markdownIt-Anchor\" href=\"#this-nfa-选择\">#</a> this | nfa  选择</h3>\n<blockquote>\n<p>设 this 和 nfa 都代表一个 nfa 图，则执行‘|’操作只需要新建 startNode 和 endNode 和四条边，将二者连接即可。</p>\n</blockquote>\n<p><img src=\"/img/%E9%80%89%E6%8B%A9%E6%93%8D%E4%BD%9C.jpg\" alt=\"选择操作\"></p>\n<h3 id=\"thisnfa连接\"><a class=\"markdownIt-Anchor\" href=\"#thisnfa连接\">#</a> thisnfa 连接</h3>\n<blockquote>\n<p>直接把 this-&gt;endNode 和 nfa -&gt; startNode 之间加一条 NFAEdge 连起来</p>\n</blockquote>\n<p><img src=\"/img/%E8%BF%9E%E6%8E%A5%E6%93%8D%E4%BD%9C.jpg\" alt=\"连接操作\"></p>\n<h3 id=\"a-闭包\"><a class=\"markdownIt-Anchor\" href=\"#a-闭包\">#</a> a* 闭包</h3>\n<blockquote>\n<p>需要新建 startNode 和 endNode，和 nfa 前后连起来，然后把 nfa 的 startNode 和 endNode 连起来。总结一下，就是新建两个结点和四条边。</p>\n</blockquote>\n<p><img src=\"/img/%E9%97%AD%E5%8C%85.jpg\" alt=\"闭包\"></p>\n<h3 id=\"生成nfa\"><a class=\"markdownIt-Anchor\" href=\"#生成nfa\">#</a> 生成 NFA</h3>\n<blockquote>\n<p>获取 NFA 图，由输入的正则表达式产生 NFA</p>\n<p>正则表达式转 NFA 递归方法思路： 首先把 (…) 看成一个单元素 NFA, 和 a 等价，把单个 NFA 看成一个或数个元素的 Union，即 NFA = a [|b|c…]。扫描正则表达式，首先扫描 | 进行拆分递归，逐项建立 NFA 后，用 ‘|’ 连接，对于括号要进行进行递归处理</p>\n</blockquote>\n<p><img src=\"/img/%E7%94%9F%E6%88%90NFA.jpg\" alt=\"生成NFA\"></p>\n<h3 id=\"生成dfa\"><a class=\"markdownIt-Anchor\" href=\"#生成dfa\">#</a> 生成 DFA</h3>\n<blockquote>\n<p>分为两个步骤：</p>\n<ul>\n<li>给 NFA 的结点编号并建立初始 DFA 结点</li>\n<li>确定结点与结点之间的关系，建立 DFA 的边</li>\n</ul>\n</blockquote>\n<h5 id=\"nfa结点编号建立dfa结点\"><a class=\"markdownIt-Anchor\" href=\"#nfa结点编号建立dfa结点\">#</a> NFA 结点编号，建立 DFA 结点</h5>\n<p><img src=\"/img/serializeNFA.jpg\" alt=\"serializeNFA\"></p>\n<h5 id=\"建立dfa的边\"><a class=\"markdownIt-Anchor\" href=\"#建立dfa的边\">#</a> 建立 DFA 的边</h5>\n<p><img src=\"/img/%E5%BB%BA%E7%AB%8BDFA%E7%9A%84%E8%BE%B9.jpg\" alt=\"建立DFA的边\"></p>\n<h3 id=\"最小化dfa\"><a class=\"markdownIt-Anchor\" href=\"#最小化dfa\">#</a> 最小化 DFA</h3>\n<blockquote>\n<p>分为两个步骤：</p>\n<ul>\n<li>求初态集合、终态集合并对这些集合进行划分，建立最后的 DFANode</li>\n<li>建立 DFANode 之间的边，形成最小 DFA 图</li>\n</ul>\n</blockquote>\n<h5 id=\"集合划分建立dfanode\"><a class=\"markdownIt-Anchor\" href=\"#集合划分建立dfanode\">#</a> 集合划分，建立 DFANode</h5>\n<p><img src=\"/img/%E9%9B%86%E5%90%88%E5%88%92%E5%88%86%EF%BC%8C%E7%94%9F%E6%88%90DFANode.jpg\" alt=\"集合划分，生成DFANode\"></p>\n<h5 id=\"建立dfanode的边\"><a class=\"markdownIt-Anchor\" href=\"#建立dfanode的边\">#</a> 建立 DFANode 的边</h5>\n<p><img src=\"/img/%E5%BB%BA%E7%AB%8B%E6%9C%80%E5%B0%8FDFA%E7%9A%84%E8%BE%B9.jpg\" alt=\"建立最小DFA的边\"></p>\n<h3 id=\"生成c语言代码\"><a class=\"markdownIt-Anchor\" href=\"#生成c语言代码\">#</a> 生成 c 语言代码</h3>\n<blockquote>\n<p>对于从个某结点出发的每一条边，分为两类，指向自己的，以及指向下一个结点的。对于指向自己的边，生成 while 语句；对于指向下一个结点的边，生成 if 语句，并且需要递归进入下一个结点，直到当前结点的状态为 END 时，结束递归，并回调。</p>\n</blockquote>\n<p><img src=\"/img/%E7%94%9F%E6%88%90c%E8%AF%AD%E8%A8%80%E4%BB%A3%E7%A0%81.jpg\" alt=\"生成c语言代码\"></p>\n<h2 id=\"枚举-结构体-类设计\"><a class=\"markdownIt-Anchor\" href=\"#枚举-结构体-类设计\">#</a> 枚举、结构体、类设计</h2>\n<h3 id=\"枚举\"><a class=\"markdownIt-Anchor\" href=\"#枚举\">#</a> 枚举</h3>\n<blockquote>\n<p>定义了一个枚举 State，用于标记每个结点的状态，包括 START（开始节点）, END（结束结点）, NORMAL（其他结点）</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">    定义各个结点的状态：开始，结束，普通</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">enum</span> <span class=\"hljs-title\">State</span>&#123;</span><br>    START,END,NORMAL<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n<h3 id=\"结构体\"><a class=\"markdownIt-Anchor\" href=\"#结构体\">#</a> 结构体</h3>\n<blockquote>\n<p>共四个结构体，NFANode，NFAEdge，DFANode，DFAEdge，分别代表一个 NFA 图的结点、一条 NFA 图的边、一个 DFA 图的结点、一个 DFA 图的边。接下来详细说明四个结构体的具体定义。</p>\n</blockquote>\n<h4 id=\"nfanode\"><a class=\"markdownIt-Anchor\" href=\"#nfanode\">#</a> NFANode</h4>\n<blockquote>\n<p>DFANode 用来描述一个 NFA 图的结点，其属性包括编号（id），状态 (state)，入边 (inEdges)，出边 (outEdges)</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">    NFA的结点</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">NFANode</span>&#123;</span><br>    <span class=\"hljs-comment\">//唯一标记结点</span><br>    <span class=\"hljs-keyword\">int</span> id;<br>    <span class=\"hljs-comment\">//标实该结点是否为开始结点或结束结点</span><br>    State state;<br>    <span class=\"hljs-comment\">//入边</span><br>    vector&lt;NFAEdge&gt; inEdges;<br>    <span class=\"hljs-comment\">//出边</span><br>    vector&lt;NFAEdge&gt; outEdges;<br>    <span class=\"hljs-comment\">//构造函数</span><br>    <span class=\"hljs-built_in\">NFANode</span>(<span class=\"hljs-keyword\">int</span> i, State s) : <span class=\"hljs-built_in\">id</span>(i), <span class=\"hljs-built_in\">state</span>(s)&#123;&#125;<br>    <span class=\"hljs-comment\">//空参构造函数</span><br>    <span class=\"hljs-built_in\">NFANode</span>(): <span class=\"hljs-built_in\">id</span>(DEFAULT_ID), <span class=\"hljs-built_in\">state</span>(NORMAL)&#123;&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n<h4 id=\"nfaedge\"><a class=\"markdownIt-Anchor\" href=\"#nfaedge\">#</a> NFAEdge</h4>\n<blockquote>\n<p>NFAEdge 用于描述一条 NFA 图中的边，其属性包括开始结点 (startNode)，结束结点 (endNode)，处理的字符 (word)</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">    NFA的边</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">NFAEdge</span>&#123;</span><br>    <span class=\"hljs-comment\">//该边由startNode指向endNode</span><br>    NFANode * startNode;<br>    NFANode * endNode;<br>    <span class=\"hljs-comment\">//该边处理字符word</span><br>    <span class=\"hljs-keyword\">char</span> word;<br>    <span class=\"hljs-comment\">//构造函数</span><br>    <span class=\"hljs-built_in\">NFAEdge</span>(NFANode * s, NFANode * e, <span class=\"hljs-keyword\">char</span> c): <span class=\"hljs-built_in\">startNode</span>(s), <span class=\"hljs-built_in\">endNode</span>(e), <span class=\"hljs-built_in\">word</span>(c)&#123;&#125;<br>    <span class=\"hljs-comment\">//空参构造函数</span><br>    <span class=\"hljs-built_in\">NFAEdge</span>(): <span class=\"hljs-built_in\">startNode</span>(<span class=\"hljs-literal\">NULL</span>), <span class=\"hljs-built_in\">endNode</span>(<span class=\"hljs-literal\">NULL</span>), <span class=\"hljs-built_in\">word</span>(<span class=\"hljs-string\">&#x27;\\0&#x27;</span>)&#123;&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n<h4 id=\"dfanode\"><a class=\"markdownIt-Anchor\" href=\"#dfanode\">#</a> DFANode</h4>\n<blockquote>\n<p>DFANode 用于描述一个 DFA 图的结点，其属性包括该结点的 EPSILION 闭包 (nodes)，由该结点出发的边 (edges)，结点名 (minName)，状态 (state)，还有一系列的操作，如插入边，插入结点，输出结点信息等</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//DFA结点</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">DFANode</span></span><br><span class=\"hljs-class\">&#123;</span><br>    <span class=\"hljs-comment\">//该结点的EPSILION闭包</span><br>    set&lt;<span class=\"hljs-keyword\">int</span>&gt; nodes;<br>    <span class=\"hljs-comment\">//由该结点出发的边</span><br>    vector&lt;DFAEdge&gt; edges;<br>    <span class=\"hljs-comment\">//给这个结点取个名字，A, B, C, D</span><br>    string minName;<br>    <span class=\"hljs-comment\">//该结点在DFA图中的状态</span><br>    State state = NORMAL;<br>    <span class=\"hljs-comment\">//判断结点id是否在该结点中</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">contains</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> id)</span></span>;<br>    <span class=\"hljs-comment\">//在该结点插入id</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> id)</span></span>;<br>    <span class=\"hljs-comment\">//在该结点插入边</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">insert</span><span class=\"hljs-params\">(DFAEdge edge)</span></span>;<br>    <span class=\"hljs-comment\">//将两个结点合成一个结点</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">unionNode</span><span class=\"hljs-params\">(DFANode * node)</span></span>;<br>    <span class=\"hljs-comment\">//该结点处理字符c后转变为的结点</span><br>    <span class=\"hljs-function\">DFANode * <span class=\"hljs-title\">process</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span> c)</span></span>;<br>    <span class=\"hljs-comment\">//输出该结点信息 如： &#123;1，2，4，6&#125;</span><br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">toString</span><span class=\"hljs-params\">()</span></span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n<h4 id=\"dfaedge\"><a class=\"markdownIt-Anchor\" href=\"#dfaedge\">#</a> DFAEdge</h4>\n<blockquote>\n<p>DFAEdge 用于描述一条 DFA 图的边，其属性包括指向的结点（next）和处理的字符（word）</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//DFA边</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">struct</span> <span class=\"hljs-title\">DFAEdge</span></span><br><span class=\"hljs-class\">&#123;</span><br>    <span class=\"hljs-comment\">//边指向的结点</span><br>    DFANode * next;<br>    <span class=\"hljs-comment\">//处理的字符</span><br>    <span class=\"hljs-keyword\">char</span> word;<br>    <span class=\"hljs-comment\">//构造函数</span><br>    <span class=\"hljs-built_in\">DFAEdge</span>(DFANode *n, <span class=\"hljs-keyword\">char</span> c): <span class=\"hljs-built_in\">next</span>(n), <span class=\"hljs-built_in\">word</span>(c)&#123;&#125;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n<h3 id=\"类\"><a class=\"markdownIt-Anchor\" href=\"#类\">#</a> 类</h3>\n<blockquote>\n<p>一共定义了三个类，分别是 NFA, DFA, Proxy，其中 NFA 和 DFA 类分别代表一个 NFA 图和 DFA 图，Proxy 是代理类，用于代理有关 NFA 和 DFA 类的操作，具体包括生成 NFA 图、给 NFA 图编号并生成 DFA 图、最小化 DFA 图、生成 c 语言代码等操作。</p>\n</blockquote>\n<h4 id=\"nfa\"><a class=\"markdownIt-Anchor\" href=\"#nfa\">#</a> NFA</h4>\n<blockquote>\n<p>主要涉及到选择（a | b）闭包（a*），连接（ab）操作</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">/**</span><br><span class=\"hljs-comment\">    NFA类，集成构建NFA图的操作</span><br><span class=\"hljs-comment\">*/</span><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">NFA</span>&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">//NFA图的开始结点</span><br>    NFANode * startNode;<br>    <span class=\"hljs-comment\">//NFA图的结束结点</span><br>    NFANode * endNode;<br>    <span class=\"hljs-comment\">//结点个数</span><br>    <span class=\"hljs-keyword\">int</span> nodeNumber;<br>    <span class=\"hljs-comment\">//空参构造函数</span><br>    <span class=\"hljs-built_in\">NFA</span>():<span class=\"hljs-built_in\">startNode</span>(<span class=\"hljs-literal\">NULL</span>), <span class=\"hljs-built_in\">endNode</span>(<span class=\"hljs-literal\">NULL</span>), <span class=\"hljs-built_in\">nodeNumber</span>(<span class=\"hljs-number\">2</span>)&#123;&#125;<br>    <span class=\"hljs-comment\">//初始化一个处理字符c的NFA图</span><br>    <span class=\"hljs-comment\">//这里原作者id的类型是char ？？？ 暂时没看懂，，先改成 int</span><br>    <span class=\"hljs-built_in\">NFA</span>(<span class=\"hljs-keyword\">char</span> c, <span class=\"hljs-keyword\">int</span> id1, <span class=\"hljs-keyword\">int</span> id2);<br>    <span class=\"hljs-comment\">//初始化一个识别c的标号未定的NFA图</span><br>    <span class=\"hljs-built_in\">NFA</span>(<span class=\"hljs-keyword\">char</span> c);<br>    <span class=\"hljs-comment\">//已知开始结点和结束结点</span><br>    <span class=\"hljs-built_in\">NFA</span>(NFANode * s, NFANode * e): <span class=\"hljs-built_in\">startNode</span>(s), <span class=\"hljs-built_in\">endNode</span>(e)&#123;&#125;<br>    <span class=\"hljs-comment\">//浅复制</span><br>    <span class=\"hljs-keyword\">void</span> <span class=\"hljs-keyword\">operator</span>=(<span class=\"hljs-keyword\">const</span> NFA &amp;nfa);<br>    <span class=\"hljs-comment\">// a | b 选择</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Or</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> NFA &amp;nfa)</span></span>;<br>    <span class=\"hljs-comment\">// ab 连接</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">And</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> NFA &amp;nfa)</span></span>;<br>    <span class=\"hljs-comment\">// a* 闭包</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">Star</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-comment\">//当前NFA图是否为空</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">isEmpty</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span></span>;<br>    <span class=\"hljs-comment\">//id对应的结点是不是endNode</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">isEnd</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> id)</span> <span class=\"hljs-keyword\">const</span></span>;<br>    <span class=\"hljs-comment\">//获取endNode的id</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getEndId</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span></span>;<br>    <span class=\"hljs-comment\">//获取startNode的id</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getStartId</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">const</span></span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n<h4 id=\"dfa\"><a class=\"markdownIt-Anchor\" href=\"#dfa\">#</a> DFA</h4>\n<blockquote>\n<p>用于描述一个 DFA 图，其主要操作涉及到由该结点生成该结点对应的 c 语言代码</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-comment\">//DFA类</span><br><br><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">DFA</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">//DFA图的结点</span><br>    vector&lt;DFANode*&gt; graph;<br>    <span class=\"hljs-comment\">//通过id返回图的结点</span><br>    <span class=\"hljs-function\">vector&lt;DFANode*&gt; <span class=\"hljs-title\">getNodes</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> id)</span></span>;<br>    <span class=\"hljs-comment\">//DFA图最小开始结点</span><br>    DFANode *minStartNode;<br>    <span class=\"hljs-comment\">//DFA图最小结束结点</span><br>    vector&lt;DFANode*&gt; minEndNodes;<br>    <span class=\"hljs-comment\">//能处理的字符</span><br>    set&lt;<span class=\"hljs-keyword\">char</span>&gt; wordList;<br>    <span class=\"hljs-comment\">//建一个新结点</span><br>    <span class=\"hljs-function\">DFANode* <span class=\"hljs-title\">crateNewNode</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> id)</span></span>;<br>    <span class=\"hljs-comment\">//判断两个结点的转化是否等价，若转化后是同一个结点，则等价</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">static</span> <span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">equals</span><span class=\"hljs-params\">(DFANode *node1, DFANode *node2, set&lt;<span class=\"hljs-keyword\">char</span>&gt; words)</span></span>;<br>    <span class=\"hljs-comment\">//判断该结点是否为结束结点</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">isEndNode</span><span class=\"hljs-params\">(DFANode *node)</span> <span class=\"hljs-keyword\">const</span></span>;<br>    <span class=\"hljs-comment\">//从当前DFA中删除某个结点</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">delNode</span><span class=\"hljs-params\">(DFANode *node)</span></span>;<br>    <span class=\"hljs-comment\">//获取该结点的c语言代码，n是结点指针，lines是生成的代码，tabNumber是缩进数</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">getCode</span><span class=\"hljs-params\">(DFANode *n, vector&lt;string&gt; &amp;lines, <span class=\"hljs-keyword\">int</span> tabNumber)</span></span>;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-comment\">//获取缩进的空格</span><br>    <span class=\"hljs-function\">string <span class=\"hljs-title\">getTabs</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> tabNumber)</span></span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n<h4 id=\"proxy\"><a class=\"markdownIt-Anchor\" href=\"#proxy\">#</a> Proxy</h4>\n<blockquote>\n<p>代理 NFA 和 DFA 的操作，包括产生 NFA，产生 DFA，最小化 DFA</p>\n</blockquote>\n<figure class=\"highlight c++\"><table><tr><td class=\"gutter hljs\"><div class=\"hljs code-wrapper\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></div></td><td class=\"code\"><div class=\"hljs code-wrapper\"><pre><code class=\"hljs c++\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Proxy</span></span><br><span class=\"hljs-class\">&#123;</span><br><span class=\"hljs-keyword\">public</span>:<br>    <span class=\"hljs-comment\">//正则表达式</span><br>    string regularExpression;<br>    <span class=\"hljs-comment\">//NFA图</span><br>    NFA nfa;<br>    <span class=\"hljs-comment\">//最初始的DFA图</span><br>    DFA dfa;<br>    <span class=\"hljs-comment\">/*</span><br><span class=\"hljs-comment\">        经过处理后的DFA图</span><br><span class=\"hljs-comment\">        因为有好几个结点最后会合成一个结点，所以minDFA其实是有好多个vector组成的，</span><br><span class=\"hljs-comment\">        每个vector元素又包含了好几个结点，这写结点最后会被合成一个结点</span><br><span class=\"hljs-comment\">        例子： minDFA = &#123;&#123;1&#125;， &#123;3，5，7&#125;, &#123;2,4&#125;, &#123;6,8&#125;&#125;</span><br><span class=\"hljs-comment\">     */</span><br>    vector&lt;vector&lt;DFANode *&gt;&gt; minDFA;<br>    <span class=\"hljs-comment\">//最终的DFA</span><br>    DFA finalDFA;<br>    <span class=\"hljs-comment\">//DFA最小化生成的表格</span><br>    <span class=\"hljs-keyword\">char</span> chart[MAX_NODE_NUMBER][MAX_NODE_NUMBER];<br>    <span class=\"hljs-comment\">//最后生成的代码</span><br>    string code;<br>    <span class=\"hljs-comment\">//能处理的字符集</span><br>    set&lt;<span class=\"hljs-keyword\">char</span>&gt; wordList;<br>    <span class=\"hljs-comment\">//构造函数，用正则表达式来初始化Proxy代理类</span><br>    <span class=\"hljs-built_in\">Proxy</span>(<span class=\"hljs-keyword\">const</span> string regExp);<br>    <span class=\"hljs-comment\">//给NFA的结点编号并建立初始DFA结点</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">serializeNFA</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-comment\">//初始DFA图后处理</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">processDFA</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-comment\">//最小化DFA</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">minimizeDFA</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-comment\">//最小DFA图后处理</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">processMinDFA</span><span class=\"hljs-params\">()</span></span>;<br>    <span class=\"hljs-comment\">//生成c语言代码</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">generateCode</span><span class=\"hljs-params\">()</span></span>;<br><span class=\"hljs-keyword\">private</span>:<br>    <span class=\"hljs-comment\">//获取NFA图，由输入的正则表达式产生NFA</span><br>    <span class=\"hljs-function\">NFA <span class=\"hljs-title\">getNFA</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> string regExp)</span></span>;<br>    <span class=\"hljs-comment\">//把正则表达式看成 a | b | c的形式，以&#x27;|&#x27;为分隔符号，所以要先获取&#x27;|&#x27; 的索引</span><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">getOrOperatorIndex</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> string regExp)</span></span>;<br>    <span class=\"hljs-comment\">//判断ch是不是字符（字母或数字）</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">bool</span> <span class=\"hljs-title\">isLetter</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">char</span> ch)</span></span>;<br>    <span class=\"hljs-comment\">//获取索引为index的左括号对应的右括号的索引，在初始化NFA的时候会用到</span><br>    <span class=\"hljs-function\"><span class=\"hljs-keyword\">int</span> <span class=\"hljs-title\">getRightBracketIndex</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">const</span> string regExp, <span class=\"hljs-keyword\">const</span> <span class=\"hljs-keyword\">int</span> leftIndex)</span></span>;<br>    <span class=\"hljs-comment\">//用于得知id号结点可以有哪些转化</span><br>    <span class=\"hljs-function\">vector&lt;<span class=\"hljs-keyword\">int</span>&gt; <span class=\"hljs-title\">getConnections</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span> id)</span></span>;<br>&#125;;<br></code></pre></div></td></tr></table></figure>\n",
            "tags": [
                "编译原理",
                "SCNU-CS",
                "XLEX"
            ]
        }
    ]
}